;====================================================================
; Main.asm file generated by New Project wizard
;
; Created:   周三 九月 13 2023
; Processor: AT89C51
; Compiler:  ASEM-51 (Proteus)
;====================================================================

$NOMOD51
$INCLUDE (8051.MCU)

;====================================================================
; DEFINITIONS
;====================================================================

;====================================================================
; VARIABLES
;====================================================================

;====================================================================
; RESET and INTERRUPT VECTORS
;====================================================================


      ; Reset Vector
      org   0000h
      jmp   Start
      org 000Bh
      JMP LABEL1
      ; 假设使用一个汇编器，如Keil，我们可以这样定义变量
      FLAGR6    DATA    30H 
      FLAGR7    DATA    31H  
      H8    DATA    32H
      L8    DATA    33H
      TEN1    DATA    34H
      TEN2    DATA    35H
      TEN3    DATA    36H
      TEN4    DATA    37H
      


;====================================================================
; CODE SEGMENT
;====================================================================

      org   0100h
Start:	
      ; Write your code here
      
      ;设置中断允许寄存器IE
      
      ;MOV DPTR, #08AH
      ;MOV A, #82H
      ;MOVX @DPTR, A
      SETB EA
      ;MOV ES, #0H
      ;MOV ET1, #0H
      ;MOV EX1 ,#0H
      SETB ET0 
      ;MOV EX0, #0H
      
      ;设置TMOD TCON
      MOV TMOD, #02H
      ;MOV TCON, #10H
      
      ;设置T0计数器初值
      MOV TH0, #00H
      
      ;开始计数
      SETB TR0
      
      
      
      MOV R1,#10H
      MOV R2,#10H
      MOV R3,#10H
      MOV R4,#10H
      MOV R5,#0H
      MOV FLAGR6,#0H;FLAG 1计算模式
      ;MOV R7,#0H;FLAG 0前面都是0，1前面存在非0
      
      MOV A,#0H
LOOP:	
    MOV P0, #11111110B
    MOV A, P0
    CPL A
    ANL A, #11111110B
    MOV R0,#0H
    JNZ XPOS;无按键继续查
    
    MOV P0, #11111101B
    MOV A, P0
    CPL A
    ANL A, #11111101B
    MOV R0,#4H
    JNZ XPOS;无按键继续查
    
    MOV P0, #11111011B
    MOV A, P0
    CPL A
    ANL A, #11111011B
    MOV R0,#8H
    JNZ XPOS;无按键继续查
    
    MOV P0, #11110111B
    MOV A, P0
    CPL A
    ANL A, #11110111B
    MOV R0,#0CH
    JZ LOOP;无按键，继续查
    
XPOS:
    CALL DELAY
    CALL DELAY
    CJNE A,#00010000B,BUT2
    JMP ADDCONTENT
BUT2:
    CJNE A,#00100000B,BUT3
    INC R0
    JMP ADDCONTENT
BUT3:
    CJNE A,#01000000B,BUT4
    INC R0
    INC R0
    JMP ADDCONTENT
BUT4:
    CJNE A,#10000000B,LOOP
    INC R0
    INC R0
    INC R0
    JMP ADDCONTENT
    
ADDCONTENT:
    CALL KEYUP
    MOV A,R0
    SUBB A,#04H
    JZ COMPUTE
    MOV A,R0
    CJNE A,#0CH,LOAD
    
    
    MOV R1,#10H
    MOV R2,#10H
    MOV R3,#10H
    MOV R4,#10H
    JMP RESGOT
LOAD:
    ;MOV DPTR,#TABLE
    ;MOVC A,@A+DPTR
    MOV B,A
    MOV A,R1
    MOV R2,A
    MOV R1,B
RESGOT:

    JMP LOOP

KEYUP:
    MOV A, P0
    CPL A
    ANL A,#0F0H
    JNZ KEYUP;不为零则未松，回去
    RET
    
CBIT:
    MOV DPTR,#TABLE
    MOVC A,@A+DPTR
    MOV P2,A
    RET
   
CBIT2:
    MOV DPTR,#TABLE2
    MOVC A,@A+DPTR
    MOV P2,A
    RET
    

COMPUTE:

      CLR EA
      MOV DPTR,#TABLE1
      
      MOV A,R1
      MOVC A,@A+DPTR
      MOV R1,A
      
      MOV A,R2
      MOVC A,@A+DPTR
      MOV R2,A
      ADD A,R2
      MOV R2,A
      ADD A,R2
      ADD A,R2
      ADD A,R2
      ADD A,R2
      ADD A,R1
      MOV R2,A
      ANL A,#0FH
      MOV R1,A
      MOV A,R2
      ANL A,#0F0H
      RR A
      RR A
      RR A
      RR A
      MOV R2,A
      
      MOV A,R3
      MOVC A,@A+DPTR
      MOV R3,A
      
      MOV A,R4
      MOVC A,@A+DPTR
      MOV R4,A
      
      
      MOV FLAGR6,#01H;进入计算模式
      MOV FLAGR7,#0H;FLAG 0前面都是0，1前面存在非0

PROCESS:
      SETB EA
      CALL C16TO10
      CALL DELAY
      CALL DELAY
      CALL DELAY
      CALL DELAY
      CALL DELAY
      MOV A,R1
      ANL A,#01H
      CLR EA
      CJNE A,#01H,D2  

X3M1:;乘3减1
      
      MOV A,R1
      ADD A,R1
      ADD A,R1
      ADD A,#01H
      MOV R1,A;R1*3+1
      
      MOV A,R2
      ADD A,R2
      ADD A,R2
      MOV R2,A;R2*3
      
      MOV A,R1
      ANL A,#0F0H
      RR A
      RR A
      RR A
      RR A
      ADD A,R2
      MOV R2,A;R1进位加入R2
      
      MOV A,R1
      ANL A,#0FH;保留后四位
      MOV R1,A
      
      MOV A,R3
      ADD A,R3
      ADD A,R3
      MOV R3,A;R3*3
      
      MOV A,R2
      ANL A,#0F0H
      RR A
      RR A
      RR A
      RR A
      ADD A,R3
      MOV R3,A;R2进位加入R3
      
      MOV A,R2
      ANL A,#0FH;保留后四位
      MOV R2,A
      
      MOV A,R4
      ADD A,R4
      ADD A,R4
      MOV R4,A;R4*3
      
      MOV A,R3
      ANL A,#0F0H
      RR A
      RR A
      RR A
      RR A
      ADD A,R4
      MOV R4,A;R3进位加入R4
      
      MOV A,R3
      ANL A,#0FH;保留后四位
      MOV R3,A
     
      MOV A,R4
      ANL A,#0FH;保留后四位
      MOV R4,A
     
      JMP CMP1

D2:;除以2
; 函数：将R4:R3:R2:R1（视为一个连续的16位数）逻辑右移一位
; 输入：R4（高8位），R3，R2，R1（低8位，只用了低四位）
; 输出：R4:R3:R2:R1 右移一位的结果
; 注意：这里假设R1的最低位是0

    ; 先移动低8位
    MOV A, R1      ; 将R1的值移动到累加器
    RR A           ; 对累加器中的值进行逻辑右移
    MOV R1, A      ; 将移动后的值存回R1

    MOV A, R2      ; 接着处理R2
    CLR C
    RRC A           ; 逻辑右移
    MOV R2, A      ; 更新R2
    CLR A
    RLC A
    RL A
    RL A
    RL A
    ORL A, R1
    MOV R1, A
    
    MOV A, R3      ; 接着处理R3
    CLR C
    RRC A           ; 逻辑右移
    MOV R3, A      ; 更新R2
    CLR A
    RLC A
    RL A
    RL A
    RL A
    ORL A, R2
    MOV R2, A
    
    MOV A, R4      ; 接着处理R3
    CLR C
    RRC A           ; 逻辑右移
    MOV R4, A      ; 更新R2
    CLR A
    RLC A
    RL A
    RL A
    RL A
    ORL A, R3
    MOV R3, A
    


CMP1:
      MOV A,R4
      CJNE A,#00H,JUMPPROCESS
      
      MOV A,R3
      CJNE A,#00H,JUMPPROCESS
      
      MOV A,R2
      CJNE A,#00H,JUMPPROCESS
      
      MOV A,R1
      CJNE A,#01H,JUMPPROCESS
      
      MOV FLAGR6,#00H;退出计算模式
      MOV A,#0DH
      MOV R1,A
      MOV A,#10H
      MOV R2,A
      MOV R3,A
      MOV R4,A
      SETB EA
      JMP LOOP;结果为1，结束，重新开始扫描输入
      
JUMPPROCESS:
      JMP PROCESS
DELAY:
   ;CLR EA
   PUSH ACC
   MOV A,R6 
   PUSH ACC
   MOV A,R7
   PUSH ACC

   MOV R6, #0FFH
DELAY_1:
   MOV R7, #0FFH
   DJNZ R7, $
   DJNZ R6, DELAY_1
   
   POP ACC
   MOV R7,A
   POP ACC
   MOV R6,A
   POP ACC
   ;SETB EA
   RET

   
C16TO10:
   CLR EA
   MOV A,R4
   RL A
   RL A
   RL A
   RL A
   ORL A,R3
   MOV H8,A
   MOV A,R2
   RL A
   RL A
   RL A
   RL A
   ORL A,R1
   MOV L8,A
   MOV A,#0H
   MOV TEN1,A
   MOV TEN2,A
   MOV TEN3,A
   MOV TEN4,A
   
; 假设R2:R1是您的16位数，其中R2存储高字节，R1存储低字节
; 检查这个数是否大于或等于1000
CHECK1000:
; 首先比较高字节
   MOV A, H8
   CLR C
   SUBB A,#03H
   JC BELOW_1000; 有借位就是小于
   JB ACC.7, BELOW_1000; 如果高字节等于0x03但最高位为1（负数），则小于1000
   JZ CHECK_LOWER; 相等需要进一步判断低八位
   JMP ABOVE_1000; 剩下的就是大于
   

CHECK_LOWER:
    MOV A, L8
    CLR C
    SUBB A,#0E8H
    JC BELOW_1000; 有借位就是小于
    JMP ABOVE_1000

BELOW_1000:
    ; 这里是小于1000的处理代码
    SJMP CHECK100           ; 跳转到检查结束后的代码

ABOVE_1000:
    ; 这里是大于或等于1000的处理代码
    ; 执行减法操作
    MOV A, L8
    CLR C
    SUBB A, #0E8H
    MOV L8, A
    MOV A, H8
    SUBB A, #03H
    MOV H8, A
    
    MOV A,TEN4
    ADD A,#01H
    MOV TEN4,A
    JMP CHECK1000


; 假设R2:R1是您的16位数，其中R2存储高字节，R1存储低字节
; 检查这个数是否大于或等于100
CHECK100:
; 首先检查高字节，如果高字节大于0则整数一定大于100
   MOV A, H8
   JNZ ABOVE_100
   JB ACC.7, BELOW_100 ; 如果高字节为0但最高位为1（负数），则小于100

; 如果高字节为0，检查低字节是否大于或等于0x64
   MOV A, L8
   CLR C
   SUBB A, #64H
   JC BELOW_100       ; 如果产生借位，则原数小于100

ABOVE_100:
    ; 这里是大于或等于100的处理代码
    ; 执行减法操作
    MOV A, L8
    CLR C
    SUBB A, #64H       ; 减去100的低字节
    MOV L8, A
    MOV A, H8
    SUBB A, #00        ; 减去100的高字节，考虑低字节的借位
    MOV H8, A
    
    MOV A,TEN3
    ADD A,#01H
    MOV TEN3,A
    JMP CHECK100

BELOW_100:
    ; 这里是小于100的处理代码
    ; 无需执行减法操作

CHECK10:
; 首先检查高字节，如果高字节大于0则整数一定大于10
   MOV A, H8
   JNZ ABOVE_10
   JB ACC.7, BELOW_10 ; 如果高字节为0但最高位为1（负数），则小于10
   
; 如果高字节为0，检查低字节是否大于或等于0x0a
   MOV A, L8
   CLR C
   SUBB A, #0AH
   JC BELOW_10       ; 如果产生借位，则原数小于100
   
ABOVE_10:
    ; 这里是大于或等于100的处理代码
    ; 执行减法操作
    MOV A, L8
    CLR C
    SUBB A, #0AH       ; 减去100的低字节
    MOV L8, A
    MOV A, H8
    SUBB A, #00        ; 减去100的高字节，考虑低字节的借位
    MOV H8, A
    
    MOV A,TEN2
    ADD A,#01H
    MOV TEN2,A
    JMP CHECK10

BELOW_10:
    MOV A,L8
    MOV TEN1,A
    SETB EA
    RET
   
;中断处理程序
LABEL1:
      CLR EA
      PUSH ACC
      MOV A,FLAGR6
      ;SUBB A,#0H
      JNZ CMODE
      JMP IMODE
CMODE:     ;计算模式
      ;MOV R7,#0H
      MOV A, R5
      CLR C
      SUBB A, #1H
      JC CDISPLAY0
      MOV A, R5
      CLR C
      SUBB A, #2H
      JC CDISPLAY1
      MOV A, R5
      CLR C
      SUBB A, #3H
      JC CDISPLAY2
      JMP CDISPLAY3   
CDISPLAY0:
      MOV P1,#11111110B
      MOV A,TEN4
      ;SUBB A,#0H
      JZ CD1S0
      ;SUBB A,#10H
      ;JZ ERROR
      MOV A,TEN4
      CALL CBIT2
      INC R5
      MOV FLAGR7,#01H
      JMP NEXT
CD1S0:
      MOV A,#10H
      CALL CBIT2
      INC R5
      MOV FLAGR7,#00H
      JMP NEXT
      
CDISPLAY1:
      MOV P1,#11111101B
      MOV A,TEN3
      ADD A,FLAGR7
      ;SUBB A,#0H
      JZ CD1S1
      ;SUBB A,#10H
      ;JZ ERROR
      MOV A,TEN3
      CALL CBIT2
      INC R5
      MOV FLAGR7,#01H
      JMP NEXT
CD1S1:
      MOV A,#10H
      CALL CBIT2
      INC R5
      MOV FLAGR7,#00H
      JMP NEXT
      
CDISPLAY2:
      MOV P1,#11111011B
      MOV A,TEN2
      ADD A,FLAGR7
      ;SUBB A,#0H
      JZ CD1S2
      ;SUBB A,#10H
      ;JZ ERROR
      MOV A,TEN2
      CALL CBIT2
      INC R5
      MOV FLAGR7,#01H
      JMP NEXT
CD1S2:
      MOV A,#10H
      CALL CBIT2
      INC R5
      MOV FLAGR7,#00H
      JMP NEXT
      
CDISPLAY3:
      MOV P1,#11110111B
      MOV A,TEN1
      ;SUBB A,#10H
      ;JZ ERROR
      MOV A,TEN1
      CALL CBIT2
      MOV R5,#0H
      MOV FLAGR7,#0H
      JMP NEXT

ERROR: 
      RETI
      
IMODE:     ;输入模式
      MOV A, R5
      CLR C
      SUBB A, #1H
      JC DISPLAY0
      MOV A, R5
      CLR C
      SUBB A, #2H
      JC DISPLAY1
      MOV A, R5
      CLR C
      SUBB A, #3H
      JC DISPLAY2
      JMP DISPLAY3   
DISPLAY0:
      MOV P1,#11110111B
      MOV A,R1
      CALL CBIT
      INC R5
      JMP NEXT
DISPLAY1:
      MOV P1,#11111011B
      MOV A,R2
      CALL CBIT
      INC R5
      JMP NEXT
DISPLAY2:
      MOV P1,#11111101B
      MOV A,R3
      CALL CBIT
      INC R5
      JMP NEXT
DISPLAY3:
      MOV P1,#11111110B
      MOV A,R4
      CALL CBIT
      MOV R5,#0H
      
NEXT:
      POP ACC
      SETB EA
      RETI

TABLE:
   ;  +    -    *    /    =    3    6    9    0    2    5    8    C    1    4    7   NULL
   DB 79H, 40H, 79H, 79H, 79H, 4FH, 7DH, 6FH, 3FH, 5BH, 6DH, 7FH, 00H, 06H, 66H, 07H, 00H
TABLE1:
   ;  +    -    *    /    =    3    6    9    0    2    5    8    C    1    4    7
   DB 00H, 00H, 00H, 00H, 00H, 03H, 06H, 09H, 00H, 02H, 05H, 08H, 00H, 01H, 04H, 07H, 00H
   
TABLE2:
   ;   0    1    2    3    4    5    6    7    8    9    A    b    C    d    e    f  NULL
   DB 3fH, 06H, 5bH, 4fH, 66H, 6dH, 7dH, 07H, 7fH, 6fH, 77H, 7cH, 39H, 5eH, 79H, 71H, 00H 
;====================================================================
      END
